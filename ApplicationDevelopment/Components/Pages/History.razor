@page "/history"
@using ApplicationDevelopment.Model
@using ApplicationDevelopment.Service
@using Markdig
@inject NavigationManager NavManager
@inject IJSRuntime JS 
@inject PdfExportService PdfService

@if (isChecking)
{
    <p></p>
}
else if (!isAllowed)
{
    <p></p>
}
else
{
<div class="history-container">

    <h3>üìú Journal History</h3>

    <!-- Filter and search section -->
    <div class="filter-bar">

        <!-- Search by title, content, or tags -->
        <input type="text" class="form-control search-input"
               placeholder="Search title, content or #tags..."
               @bind="_searchText" @bind:event="oninput" />

        <!-- Date range filters -->
        <input type="date" class="form-control" @bind="fromDate" />
        <input type="date" class="form-control" @bind="toDate" />

        <!-- Filter by primary mood -->
        <select class="form-control" @bind="selectedMood">
            <option value="">All Moods</option>
            @foreach (var mood in moodList)
            {
                <option value="@mood">@mood</option>
            }
        </select>

        <!-- Filter by mood category -->
        <select class="form-control" @bind="selectedMoodCategory">
            <option value="">All Mood Categories</option>
            <option value="Positive">Positive</option>
            <option value="Neutral">Neutral</option>
            <option value="Negative">Negative</option>
        </select>

        <!-- Filter by tags -->
        <select class="form-control" @bind="selectedTag">
            <option value="">All Tags</option>
            @foreach (var tag in tagList)
            {
                <option value="@tag">@tag</option>
            }
        </select>

        <!-- Apply filters button -->
        <button class="btn btn-primary btn-sm" @onclick="ApplyFilters">
            Apply Filters
        </button>

        <!-- Export filtered entries to PDF -->
        <button class="btn btn-success btn-sm" @onclick="ExportPdf">
            üìÑ Export PDF
        </button>
    </div>

    <hr />

    @if (GetFilteredEntries().Count == 0)
    {
        <p class="text-center text-muted mt-5">No entries found.</p>
    }
    else
    {
        <div class="history-list">
            @foreach (var item in GetFilteredEntries())
            {
                <div class="card history-card">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-start">
                            <!-- Display entry creation date and time -->
                            <small class="text-muted">@item.CreatedAt.ToString("MMM dd, yyyy HH:mm")</small>
                            <div>
                                <!-- Edit existing journal entry -->
                                <button class="btn btn-sm btn-outline-primary me-2" @onclick="() => Edit(item.Id)">Edit</button>
                                <!-- Delete journal entry -->
                                <button class="btn btn-sm btn-outline-danger" @onclick="() => Delete(item.Id)">Delete</button>
                            </div>
                        </div>

                        <!-- Entry title -->
                        <h5 class="fw-bold mt-2">@item.Title</h5>

                        <!-- Render journal content with Markdown support -->
                        <div class="mt-2 lead">
                            @((MarkupString)Markdown.ToHtml(item.Content ?? ""))
                        </div>

                        <!-- Display moods (primary and secondary) -->
                        <p class="mb-2">
                            <strong>Mood:</strong>
                            @item.PrimaryMood
                            @(string.IsNullOrEmpty(item.SecondaryMood1) ? "" : " / " + item.SecondaryMood1)
                            @(string.IsNullOrEmpty(item.SecondaryMood2) ? "" : " / " + item.SecondaryMood2)
                        </p>

                        <!-- Display mood category -->
                        <p class="mb-2">
                            <strong>Mood Category:</strong> @item.MoodCategory
                        </p>

                        <!-- Display tags associated with the entry -->
                        <div>
                            @foreach (var t in item.Tags)
                            {
                                <span class="badge tag-badge">@t</span>
                            }
                        </div>
                    </div>
                </div>
            }
        </div>

        <!-- Pagination controls -->
        <div class="d-flex justify-content-center align-items-center mt-3">
            <button class="btn btn-sm btn-outline-primary me-2"
                    disabled="@(_currentPage == 1)"
                    @onclick="PrevPage">
                ‚óÄ Prev
            </button>

            <span>
                Page @_currentPage of @_totalPages
            </span>

            <button class="btn btn-sm btn-outline-primary ms-2"
                    disabled="@(_currentPage == _totalPages)"
                    @onclick="NextPage">
                Next ‚ñ∂
            </button>
        </div>
    }
</div>
}

<style>
/* Page layout and styling (unchanged) */
.history-container {
    background-color: #E6F2FF;
    min-height: 100vh;
    padding: 2rem;
}

.filter-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.search-input {
    border-radius: 0.5rem;
    border: 1px solid #00B4D8;
    min-width: 200px;
}

.history-card {
    border: none;
    border-left: 5px solid #00B4D8;
    border-radius: 0.5rem;
    margin-bottom: 1.5rem;
    background-color: #ffffff;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}

.tag-badge {
    background-color: #00B4D8;
    color: #fff;
    margin-right: 0.3rem;
    padding: 0.3rem 0.5rem;
    border-radius: 0.4rem;
    font-size: 0.85rem;
}
</style>

@code {
    // Flags to control authentication and loading state
    private bool isChecking = true;
    private bool isAllowed = false;

    // Search input text
    private string _searchText = "";

    // Stores all journal entries from database
    private List<JournalEntry> _entries = new();

    // Filter variables
    private DateTime? fromDate;
    private DateTime? toDate;
    private string selectedMood = "";
    private string selectedTag = "";
    private string selectedMoodCategory = "";

    // Lists used to populate filter dropdowns
    private List<string> moodList = new();
    private List<string> tagList = new();

    // Pagination variables
    private int _currentPage = 1;
    private int _pageSize = 5;
    private int _totalPages = 1;

    // Load entries and initialize filters when page loads
    protected override async Task OnInitializedAsync()
    {
        isAllowed = AuthService.IsLoggedIn();
        isChecking = false;

        if (!isAllowed)
        {
            NavManager.NavigateTo("/login", true);
            return;
        }

        _entries = await JournalService.GetAllEntriesAsync();

        foreach (var e in _entries)
            e.LoadTags();

        // Build mood filter list
        moodList = _entries.Select(e => e.PrimaryMood)
            .Where(m => !string.IsNullOrEmpty(m))
            .Distinct()
            .ToList();

        // Build tag filter list
        tagList = _entries.SelectMany(e => e.Tags)
            .Distinct()
            .ToList();

        CalculatePages();
    }

    // Apply filters and reset pagination
    private void ApplyFilters()
    {
        _currentPage = 1;
        CalculatePages();
    }

    // Returns filtered and paginated list of journal entries
    private List<JournalEntry> GetFilteredEntries()
    {
        IEnumerable<JournalEntry> filtered = _entries;

        // Search filter: title, content, and tags
        if (!string.IsNullOrWhiteSpace(_searchText))
        {
            filtered = filtered.Where(x =>
                (x.Title != null && x.Title.Contains(_searchText, StringComparison.OrdinalIgnoreCase)) ||
                (x.Content != null && x.Content.Contains(_searchText, StringComparison.OrdinalIgnoreCase)) ||
                x.Tags.Any(t => t.Contains(_searchText, StringComparison.OrdinalIgnoreCase))
            );
        }

        // Date range filtering
        if (fromDate != null)
            filtered = filtered.Where(x => x.CreatedAt.Date >= fromDate.Value.Date);

        if (toDate != null)
            filtered = filtered.Where(x => x.CreatedAt.Date <= toDate.Value.Date);

        // Mood filtering
        if (!string.IsNullOrEmpty(selectedMood))
            filtered = filtered.Where(x => x.PrimaryMood == selectedMood);

        // Mood category filtering
        if (!string.IsNullOrEmpty(selectedMoodCategory))
            filtered = filtered.Where(x => x.MoodCategory == selectedMoodCategory);

        // Tag filtering
        if (!string.IsNullOrEmpty(selectedTag))
            filtered = filtered.Where(x => x.Tags.Contains(selectedTag));

        var list = filtered.ToList();

        // Calculate total pages based on filtered results
        _totalPages = (int)Math.Ceiling(list.Count / (double)_pageSize);
        if (_totalPages == 0) _totalPages = 1;

        return list
            .Skip((_currentPage - 1) * _pageSize)
            .Take(_pageSize)
            .ToList();
    }

    // Calculate total pages based on all entries
    private void CalculatePages()
    {
        _totalPages = (int)Math.Ceiling(_entries.Count / (double)_pageSize);
        if (_totalPages == 0) _totalPages = 1;
    }

    // Move to next page
    private void NextPage()
    {
        if (_currentPage < _totalPages)
            _currentPage++;
    }

    // Move to previous page
    private void PrevPage()
    {
        if (_currentPage > 1)
            _currentPage--;
    }

    // Navigate to edit page for selected entry
    private void Edit(Guid id)
    {
        NavManager.NavigateTo($"/edit-entry/{id}");
    }

    // Delete an entry and reload data
    private async Task Delete(Guid id)
    {
        await JournalService.DeleteEntryAsync(id);
        _entries = await JournalService.GetAllEntriesAsync();

        foreach (var e in _entries)
            e.LoadTags();

        CalculatePages();
    }

    // Export filtered journal entries to PDF
    private async Task ExportPdf()
    {
        try
        {
            var entriesToExport = GetFilteredEntries();

            if (entriesToExport.Count == 0)
            {
                await JS.InvokeVoidAsync("alert", "No entries to export!");
                return;
            }

            var pdfBytes = PdfService.GenerateJournalPdf(entriesToExport);
            var filePath = await PdfFileSaver.SavePdfAsync(pdfBytes);

            await JS.InvokeVoidAsync("alert", $"‚úÖ PDF saved!\n\nLocation:\n{filePath}");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("alert", "‚ùå PDF Error:\n" + ex.Message);
        }
    }
}
